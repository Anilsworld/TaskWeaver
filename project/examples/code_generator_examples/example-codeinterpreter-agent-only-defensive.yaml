enabled: True
rounds:
  - user_query: Create a workflow to fetch data, analyze it, and send report
    state: created
    post_list:
      - message: Create a workflow to fetch data, analyze it, and send report
        send_from: User
        send_to: Planner
        attachment_list: []
      - message: Fetch data from source, analyze the data, and send report via email.
        send_from: Planner
        send_to: CodeInterpreter
        attachment_list:
          - type: init_plan
            content: |-
              1. Fetch data from source
              2. Analyze data and generate insights <depends on 1>
              3. Send report via email <depends on 2>
          - type: plan
            content: Generate complete workflow with data fetching, analysis, and reporting
          - type: current_plan_step
            content: Generate complete workflow
          - type: stop
            content: InProcess
      - message: The following python code has been executed
        send_from: CodeInterpreter
        send_to: Planner
        attachment_list:
          - type: thought
            content: |-
              **IMPLEMENTING WORKFLOW WITH agent_only NODE:**
              
              1. Fetch data (agent_with_tools) - uses Composio
              2. Analyze data (agent_only) - uses Python code
              3. Send report (agent_with_tools) - uses Composio
              
              For agent_only node, I'll write DEFENSIVE code that:
              - Uses .get() for safe dict access
              - Checks data types
              - Handles missing/null values
              - Has fallback logic
              
              This ensures code works even if data structure is unexpected.
          - type: reply_type
            content: python
          - type: reply_content
            content: |-
              # ===== WORKFLOW DEFINITION =====
              WORKFLOW = {
                "nodes": [
                  {"id": "fetch_data", "type": "agent_with_tools", "tool_id": "API_FETCH_DATA", "app_name": "data_source", "description": "Fetch data from source"},
                  {"id": "analyze_data", "type": "agent_only", "description": "Analyze fetched data and generate insights", "params": {"data": "${from_step:fetch_data.output}"}, "depends_on": ["fetch_data"]},
                  {"id": "send_report", "type": "agent_with_tools", "tool_id": "GMAIL_SEND_EMAIL", "app_name": "gmail", "params": {"to": "user@example.com", "subject": "Data Analysis Report", "body": "${from_step:analyze_data.report}"}, "depends_on": ["analyze_data"], "description": "Send analysis report via email"}
                ],
                "parallel_groups": {},
                "conditional_edges": [],
                "sequential_edges": [("fetch_data", "analyze_data"), ("analyze_data", "send_report")]
              }
              
              # ===== PYTHON CODE FOR agent_only NODE: analyze_data =====
              # âš¡ DEFENSIVE CODE PATTERN (works with ANY data structure):
              
              # Get data from previous step (safe access)
              fetch_output = tool_outputs.get('fetch_data', {})
              data = fetch_output.get('output', fetch_output.get('data', {}))
              
              # Initialize results with defaults (prevents errors if data missing)
              analysis = {
                  'total_records': 0,
                  'summary': 'No data available',
                  'insights': [],
                  'recommendations': []
              }
              
              # Process data ONLY if it exists and is valid
              if data and isinstance(data, dict):
                  # Safe extraction of fields
                  records = data.get('records', data.get('items', []))
                  
                  if isinstance(records, list) and len(records) > 0:
                      analysis['total_records'] = len(records)
                      
                      # Analyze metrics (defensive)
                      try:
                          # Extract numeric values safely
                          metrics = []
                          for record in records:
                              if isinstance(record, dict):
                                  value = record.get('value', record.get('amount', 0))
                                  # Type check before calculation
                                  if isinstance(value, (int, float)) and value > 0:
                                      metrics.append(value)
                          
                          # Calculate stats ONLY if we have data
                          if metrics:
                              avg = sum(metrics) / len(metrics)
                              max_val = max(metrics)
                              min_val = min(metrics)
                              
                              analysis['summary'] = f'Analyzed {len(metrics)} records'
                              analysis['insights'] = [
                                  f'Average: {avg:.2f}',
                                  f'Range: {min_val:.2f} to {max_val:.2f}'
                              ]
                              
                              # Generate recommendations based on patterns
                              if avg > 1000:
                                  analysis['recommendations'].append('High performance detected')
                              elif avg < 100:
                                  analysis['recommendations'].append('Consider optimization')
                          else:
                              analysis['summary'] = 'No valid numeric data found'
                      
                      except Exception as e:
                          # Fallback if any calculation fails
                          analysis['summary'] = f'Analysis error: {str(e)}'
                          analysis['insights'] = ['Could not complete full analysis']
                  else:
                      analysis['summary'] = 'No records found in data'
              else:
                  analysis['summary'] = 'Invalid data format received'
              
              # Format report for email (always returns valid result)
              report = f"""
              Data Analysis Report
              ====================
              
              Total Records: {analysis['total_records']}
              Summary: {analysis['summary']}
              
              Insights:
              {chr(10).join('- ' + i for i in analysis['insights']) if analysis['insights'] else '- None'}
              
              Recommendations:
              {chr(10).join('- ' + r for r in analysis['recommendations']) if analysis['recommendations'] else '- None'}
              """
              
              # Store result
              result = {
                  'analysis': analysis,
                  'report': report.strip()
              }
          - type: verification
            content: CORRECT
          - type: code_error
            content: No code error.
          - type: execution_status
            content: SUCCESS
          - type: execution_result
            content: Workflow generated with defensive code for agent_only node
      - message: Workflow complete! It fetches data, analyzes it defensively, and sends a report.
        send_from: Planner
        send_to: User
        attachment_list:
          - type: stop
            content: Completed

